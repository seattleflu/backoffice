#!/usr/bin/env python3
"""
Join the REDCap csv data with an ID3C csv.
Parses the joined data to make it suitable for UW Lab Med's return of results
portal.
"""
import sys
import argparse
import pandas as pd


def parse_redcap(redcap_file) -> pd.DataFrame:
    """
    Reads in data from a given *redcap_file*. Returns a pandas.DataFrame
    prepared in the specifications of UW Lab Med's return of results portal.
    """
    redcap_data = (
        pd.read_csv(redcap_file, dtype = 'string')
        .pipe(trim_whitespace)
        .replace("", pd.NA)
        .rename(columns={'birthday': 'birth_date'}))

    participant_name = lambda row: f"{row['participant_first_name']} {row['participant_last_name']}"
    redcap_data['pat_name'] = redcap_data.apply(participant_name, axis='columns')

    # This invariant protects our filename assumptions.
    assert all(redcap_data['birth_date'].str.match(r"^\d{4}-\d{2}-\d{2}$").dropna())

    # Only use the barcode scanned during unboxing, which is input only after
    # confirming identity.
    barcodes = normalize_barcode(redcap_data['return_utm_barcode'])

    # There should be absolutely no duplicates, but REDCap can't enforce this,
    # so warn and drop any that we find.
    dups = barcodes.loc[barcodes.duplicated(keep = False)].dropna()

    if not dups.empty:
        barcodes.drop(dups.index, inplace = True)

        dups_count = len(dups)
        dups_unique = list(dups.unique())
        print(f"Dropped {dups_count:,} REDCap records with duplicated barcodes: {dups_unique}", file = sys.stderr)

    redcap_data['qrcode'] = barcodes

    return redcap_data[['qrcode', 'pat_name', 'birth_date', 'contacted']]


def normalize_barcode(barcode):
    return barcode.str.upper().str.strip()


def trim_whitespace(df: pd.DataFrame) -> pd.DataFrame:
    """
    Trim leading and trailing whitespace from strings in *df*.
    """
    str_columns = df.select_dtypes("string").columns
    df[str_columns] = df[str_columns].apply(lambda column: column.str.strip())
    return df


def edit_status_code(scan_data: pd.DataFrame) -> pd.DataFrame:
    """
    Sets the *scan_data* status to `pending` if a test result is `positive` or
    `inconclusive` but the participant has not yet been contacted
    (`contacted` != 'yes').

    Returns the modified *scan_data*.
    """
    # Assume a null value for `contacted` means not contacted
    scan_data.loc[scan_data['contacted'].isnull(), 'contacted'] = 'no'

    is_positive = scan_data['status_code'] == 'positive'
    is_inconclusive = scan_data['status_code'] == 'inconclusive'

    participant_contacted = scan_data['contacted'] == 'yes'

    scan_data.loc[(is_positive | is_inconclusive) & ~(participant_contacted), 'status_code'] = 'pending'

    return scan_data


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="Join a REDCAP export csv file with a SCAN return of results ID3C export csv file."
    )
    parser.add_argument("redcap_data", help="CSV export of SCAN records from REDCap")
    parser.add_argument("id3c_data", help="CSV export of SCAN return of results from ID3C")
    parser.add_argument("output", help="A destination for the output csv", nargs="?",
        default=sys.stdout)

    args = parser.parse_args()

    redcap_data = parse_redcap(args.redcap_data)

    id3c_data = pd.read_csv(args.id3c_data, dtype = 'string')
    id3c_data['qrcode'] = normalize_barcode(id3c_data['qrcode'])

    # We can't return results without participant info so keep all from redcap_data
    joined_data = redcap_data.merge(id3c_data, how='inner', on='qrcode')
    joined_data = edit_status_code(joined_data)

    joined_data[['qrcode', 'pat_name', 'birth_date', 'collect_ts', 'result_ts', 'status_code']].to_csv(args.output, index=False)
